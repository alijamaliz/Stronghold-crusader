package StrongholdCrusader.GameObjects.Humans;import StrongholdCrusader.GameObjects.GameObject;import StrongholdCrusader.Map.MapGUI;import StrongholdCrusader.Map.MapTile;import StrongholdCrusader.Map.Mountain;import StrongholdCrusader.Map.Sea;import StrongholdCrusader.ResourceManager;import StrongholdCrusader.Settings;import javafx.animation.Animation;import javafx.animation.KeyFrame;import javafx.animation.Timeline;import javafx.util.Duration;import java.util.HashMap;import java.util.LinkedList;import java.util.Queue;/** * Created by Baran on 5/29/2017. */public abstract class Human extends GameObject {    public GameObject attackTarget;    public boolean canClimb;    public int speed;    public int zone;    public int power;    private int speedHandler;    private MapTile nextTile;    private MapTile targetTile;    public enum movingDirection {        UP, DOWN, RIGHT, LEFT    }    public enum humanMode {        IDLE, WALKING, ATTACKING    }    public humanMode mode = humanMode.IDLE;    public movingDirection direction = movingDirection.DOWN;    Timeline animationTimeLine = new Timeline();    public Human() {    }    public Human(MapGUI mapGUI) {        super(mapGUI);    }    private static LinkedList<MapTile> adjacentList(MapTile[][] tiles, MapTile tile, boolean canClimb) {        LinkedList<MapTile> adjacents = new LinkedList<>();        for (int i = tile.position.x - 1; i < tile.position.x + 2; i++) {            for (int j = tile.position.y - 1; j < tile.position.y + 2; j++) {                if ((i == tile.position.x && j != tile.position.y) || (j == tile.position.y && i != tile.position.x)) // Not adding corner tiles                {                    try {                        MapTile tmp = tiles[i][j];                        if (!tmp.filled && canClimb) { //for climbers                            if (!(tmp instanceof Sea)) {                                adjacents.add(tmp);                            }                        } else if (!tmp.filled && !canClimb) {                            if (!(tmp instanceof Mountain) && !(tmp instanceof Sea)) { // for non-climbers                                adjacents.add(tmp);                            }                        }                    } catch (Exception e) {                        ///Do Nothing becuase its Null pionter and unwanted nodes                    }                }            }        }        return adjacents;    }    public abstract void initializeAnchorPane();    public void attack(GameObject object) {        this.attackTarget = object;    }    public void updatePosition(MapTile[][] tiles) {        if (speedHandler == Settings.SEND_DATA_RATE / speed) {            if (nextTile != null) {                tiles[this.position.x][this.position.y].filled = false;                this.position = nextTile.position;                tiles[this.position.x][this.position.y].filled = true;                if (!tiles[position.x][position.y].equals(targetTile)) {                    LinkedList<MapTile> path = findRoute(tiles, tiles[position.x][position.y], targetTile, canClimb);                    if (path.size() != 0) {                        path.removeLast();                        this.nextTile = path.getLast();                    }                } else                    nextTile = null;            }            speedHandler = 0;        }        speedHandler++;    }    public void goToTile(MapTile[][] tiles, MapTile tile) {        targetTile = tile;        LinkedList<MapTile> path = findRoute(tiles, tiles[position.x][position.y], targetTile, canClimb);        if (path.size() != 0) {            path.removeLast();            this.nextTile = path.getLast();        }    }    public LinkedList<MapTile> territory(MapTile[][] tiles, MapTile tile) ///Return Zone of every Human    {        LinkedList<MapTile> territory = new LinkedList<>();        int x = tile.position.x;        int y = tile.position.y;        for (int i = x - zone; i <= x + zone; i++) {            for (int j = y - (i - x + zone); j <= y + (i - x + zone); j++) {                try {                    territory.add(tiles[i][j]);                } catch (Exception e) {                    ///Do Nothing , Becuase this Tile is Out of array                }            }        }        return territory;    }    private LinkedList<MapTile> findRoute(MapTile[][] tiles, MapTile start, MapTile end, boolean canClimb) ///BFS codes go here    {        HashMap<MapTile, Boolean> visited = new HashMap<>(); //every tile is visited or not        HashMap<MapTile, MapTile> edgeTo = new HashMap<>(); // stores where the tile comes from        LinkedList<MapTile> path = new LinkedList<>();        Queue<MapTile> queue = new LinkedList();        MapTile current = start;        queue.add(current);        visited.put(current, true);        while (!queue.isEmpty()) {            current = queue.remove();            if (current.equals(end)) {                break;            } else {                for (MapTile mapTile : adjacentList(tiles, current, canClimb)) {                    if (!visited.containsKey(mapTile)) {                        queue.add(mapTile);                        visited.put(mapTile, true);                        edgeTo.put(mapTile, current);                    }                }            }        }        if (!current.equals(end)) { // runs when there is not a way and return an empty LinkedList            return path;        }        for (MapTile tile = end; tile != null; tile = edgeTo.get(tile)) { // adding tiles to LinkedList (reversely)            path.addLast(tile);        }        return path;    }    public void changeAnimation() {    }    public void createAnimation(String imagePrefix, int framesCount) {        animationTimeLine.stop();        KeyFrame[] keyFrames = new KeyFrame[framesCount];        for (int i = 0; i < framesCount; i++) {            int finalI = i;            keyFrames[i] = new KeyFrame(Duration.millis((1000 / (Settings.FRAME_RATE * ((double) speed / 4))) * (i + 1)), event -> setImage(ResourceManager.getImage(imagePrefix + (finalI + 1))));        }        animationTimeLine = new Timeline();        animationTimeLine.setCycleCount(Animation.INDEFINITE);        animationTimeLine.setAutoReverse(false);        animationTimeLine.getKeyFrames().addAll(keyFrames);        animationTimeLine.play();    }}