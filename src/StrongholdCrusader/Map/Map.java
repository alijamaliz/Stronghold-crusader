package StrongholdCrusader.Map;import StrongholdCrusader.ClientPlayer;import StrongholdCrusader.GameObjects.GameObject;import java.io.Serializable;import java.util.HashMap;import java.util.LinkedList;import java.util.Queue;/** * Created by Baran on 5/29/2017. */public class Map implements Serializable {    public MapTile[][] tiles;    public LinkedList<GameObject> objects;    MapManager mapManager;    MapGUI gui;    ClientPlayer clientPlayer;    public Map(ClientPlayer clientPlayer) {        mapManager = new MapManager();        objects = new LinkedList<>();        gui = new MapGUI(this);        this.clientPlayer = clientPlayer;    }    public void setMapId(int id) {        tiles = mapManager.getMapTilesById(id);    }    public void showMapScreen() {        gui.showMap();        new Thread(gui).start();    }    public void sendGameEvent(int type, String message) {        clientPlayer.client.sendGameEvent(type, message);    }    public GameObject findGameObjectObjectById(int id) {        for (GameObject object : objects) {            if (object.id == id)                return object;        }        return null;    }    public static LinkedList<MapTile> adjacentList(Map map,MapTile tile,boolean canClimb)    {        LinkedList<MapTile> adjacents = new LinkedList<>();        for (int i = tile.position.x-1 ;i<tile.position.x+2;i++)        {            for (int j =tile.position.y-1 ; j<tile.position.y+2;j++)            {                if((i== tile.position.x && j!=tile.position.y) || (j==tile.position.y && i!=tile.position.x)) // Not adding corner tiles                {                    try                    {                        MapTile tmp = map.tiles[i][j];                        if(!tmp.filled && canClimb) //for climbers                        {                            if(!(tmp instanceof Sea))                            {                                adjacents.add(tmp);                            }                        }                        else if(!tmp.filled && !canClimb)                        {                            if(!(tmp instanceof Mountain) && !(tmp instanceof Sea)) // for non-climbers                            {                                adjacents.add(tmp);                            }                        }                    }                    catch (Exception e)                    {                        ///Do Nothing becuase its Null pionter and unwanted nodes                    }                }            }        }        return adjacents;    }    public LinkedList<MapTile> findRoute(MapTile start , MapTile end , boolean canClimb) ///BFS codes go here    {        HashMap<MapTile, Boolean> visited = new HashMap<>(); //every tile is visited or not        HashMap<MapTile,MapTile> edgeTo = new HashMap<>(); // stores where the tile comes from        LinkedList<MapTile> path = new LinkedList<>();        Queue<MapTile> queue = new LinkedList();        MapTile currunt = start;        queue.add(currunt);        visited.put(currunt,true);        while (!queue.isEmpty())        {            currunt = queue.remove();            if(currunt.equals(end))            {                break;            }            else            {                for (MapTile mapTile : this.adjacentList(this,currunt,canClimb)) {                    if(!visited.containsKey(mapTile))                    {                        queue.add(mapTile);                        visited.put(mapTile,true);                        edgeTo.put(mapTile,currunt);                    }                }            }        }        if(!currunt.equals(end)) // runs when there is not a way and return an empty LinkedList        {            return path;        }        for(MapTile tile = end ; tile!=null ; tile = edgeTo.get(tile)) // adding tiles to LinkedList (reversely)        {            path.addLast(tile);        }        return path;    }}